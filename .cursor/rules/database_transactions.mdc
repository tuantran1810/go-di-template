---
description:
globs: internal/usecases/**,internal/repositories/**
alwaysApply: false
---

# Overview
- Clean Architecture separates infra from business logic, making DB transaction handling non-trivial.
- This project abstracts transactions so that:
  - Use case layer **starts, propagates, and ends** transactions.
  - Repository layer **executes queries using the passed transaction**.

# Rules to adopt transactions in repository layer
- The **entities.Transaction** represents the transaction, passing this object around helps to propagate the transaction to all related business logic.
- Always accept `entities.Transaction` as a parameter in repository methods.
- Use `entities.Transaction.GetTransaction()` to extract the real DB transaction.

# Rules to adopt transactions in use case layer
- Use the most relevant repository as the transaction entrypoint.
- Expose `RunTx()` from that repository to the use case layer with the signature:
  ```go
  RunTx(ctx context.Context, funcs ...entities.DBTxHandleFunc) error
  ```
  - **ctx**: must be context with timeout.
  - **funcs**: ordered list of transaction functions
  ```go
  type DBTxHandleFunc func(ctx context.Context, dbtx entities.Transaction) error
  ```
    - Each function must propagate both ctx and dbtx to all downstream calls.
- Use transactions only when multiple repository functions must run atomically. For example:
```go
	if err := u.userRepository.RunTx(
		timeoutCtx,
		func(ictx context.Context, dbtx entities.Transaction) error {
			var ierr error
      newUser, ierr = u.userRepository.Create(ictx, dbtx, user) // the first repository function
			if ierr != nil {
				return fmt.Errorf("failed to create user: %w", ierr)
			}
			outUser, ierr = u.attributeRepository.CreateMany(ictx, dbtx, atts) // the second repository function
			if ierr != nil {
				return fmt.Errorf("failed to create attributes: %w", ierr)
			}
			return nil
		},
	); err != nil {
		return nil, err
	}
```
- **MUST NOT** use a transaction for a single repository operation — pass nil for `dbtx entities.Transaction`. For example:
```go
  newItem, err = u.itemRepository.Create(ctx, nil, item) // the only repository function
  if err != nil {
    return fmt.Errorf("failed to create item: %w", err)
  }
```

- RunTx() behavior:
  - Executes all functions in order.
  - If any function returns error → transaction is rolled back.
  - If all functions return nil → transaction is committed.
  - Business logic inside the callbacks decides success/failure by returning error appropriately.
