---
description: Dependency injection setup using Uber/fx in Go
globs: cmd/*.go
alwaysApply: false
---
# Overview
- Use [Uber/fx](https://github.com/uber-go/fx) for DI, startup, and graceful shutdown.
- fx builds a dependency graph:
  - On startup: supplies configs, constructs components in dependency order, runs `OnStart()` hooks.
  - On shutdown: reverse dependency order, runs `OnStop()` hooks.
- Always back your DI plan with a `.mmd` diagram describing interfaces, implementations, and dependencies.


# Rules
1. **Static interface checks**
   - For each realization in the diagram (`structA ..|> interfaceA`):
     ```go
     var _ interfaceA = &structA{}
     ```
2. **Create the main startup function**
  For example, if I want to start a server program, it should looks like:
  ```go
  func newServerApp() *fx.App {
    cfg := config.MustLoadConfig[config.ServerConfig]()
    log.Infof("Starting server with config: %+v", cfg)

    return fx.New(
      fx.StartTimeout(fx.DefaultTimeout),
      fx.StopTimeout(fx.DefaultTimeout),
      fx.Supply(
        cfg,
        // TODO: all neccessable configurations for all components
      ),
      fx.Provide(
        // TODO: all components of the program
      ),
      fx.Invoke(...) // TODO: invoke all sub programs belongs to the fx.App. It usually a controller or a consumer
    )
  }

  func startServer(_ *cobra.Command, _ []string) {
    newServerApp().Run()
  }
  ```
3. **Supply configurations**
  - Most the values for these configurations should come from the loaded config (the cfg variable)
  - Inspect the input diagram, for all components denoted as classes, looking for their constructors. This function may require input configuration struct in its argument
  - Try to compose all configuration structs for all components by finding the corresponding configuration in the loaded config.
4. **Provide components**
  - For each component (class in diagram, not invoked directly)
    - If a constructor exists: call it.
    - Else: init struct directly.
  - Create a `new{componentA}()` function in the same file to initialize the component A.
  - Connect the `OnStart()` and `OnStop()` hook of the app lifecycle to the component if the start and stop function of the component is available.
  - **Do not** call `new{componentA}()` more than once.
  - The `new{componentA}()` function must return **the concrete types** instead of interfaces.
  - The `new{componentA}()` function must receive **concrete type dependencies** instead of interfaces.
  - The `new{componentA}()` function should looks like:
  ```go
  func newComponentA(
    appLifecycle fx.Lifecycle,
    config a_package.ComponentAConfig,
    concreteDepX *x_package.DependencyX,
    concreteDepY *y_package.DependencyY,
  ) *a_package.ComponentA {
    c := a_package.NewComponentA(config, concreteDepX, concreteDepY)
    appLifecycle.Append(fx.Hook{
      OnStart: c.Start,
      OnStop:  c.Stop,
    })
    return c
  }
  ```
  - Provide the `new{componentA}()` to the fx:
  ```go
  fx.Provide(
    newComponentX,
    newComponentY,
    newComponentA,
    // ...
  ),
  ```
5. **Invoke top-level components**
  - Use `fx.Invoke()` for high-level services (e.g., servers, workers).
  - We also need to create a `new{componentA}()` function with `OnStart()` and `OnStop()` hook, exactly the same as the example in step 4.
  - Use `fx.Invoke()` to invoke the component:
  ```go
  fx.Invoke(newComponentA)
  ```
  - For invoking an inbound server, use the following template for the `startInboundServer()` function, which use the **/libs/server** package to initialize a server
  ```go
  func startInboundServer(
    appLifecycle fx.Lifecycle,
    cfg config.ServerConfig,
    controller *controllers.BusinessController, // change it to an appropriate controller
  ) *server.Server {
    serverConfig := server.NewServerConfig().
      SetLogger(log).
      SetGRPCAddr(fmt.Sprintf("0.0.0.0:%d", cfg.GrpcPort)).
      SetHTTPAddr(fmt.Sprintf("0.0.0.0:%d", cfg.HttpPort)).
      SetGRPCReflection(true).
      RegisterGRPC(func(s *grpc.Server) {
        pb.Register{...}ServiceServer(s, controller)
      }).
      RegisterHTTP(func(mux *runtime.ServeMux, conn *grpc.ClientConn) {
        if err := pb.Register{...}ServiceHandlerServer(globalContext, mux, controller); err != nil {
          log.Fatalln("Failed to register server:", err)
        }
      }).AddInterceptor(
      middlewares.HandleErrorCodes,
    )

    server, err := server.NewServer(serverConfig)
    if err != nil {
      log.Fatalln("Failed to create server:", err)
    }

    appLifecycle.Append(fx.Hook{
      OnStart: server.StartBackground,
      OnStop:  server.Stop,
    })

    return server
  }
  ```
6. In `cmd/cmd.go`, add a command for the new application in the `init()` function. For example, we have just created a new consumer, then:
  ```go
  func init() {
    // ...
    startConsumerCmd := &cobra.Command{
      Use:   "start-consumer",
      Short: "Starts the consumer",
      Long:  `Starts the consumer`,
      Run:   startConsumer,
    }

    RootCmd.AddCommand(startConsumerCmd)
    // ...
  }
  ```
7. **Verify dependency injection at runtime**
  - Compilation success ≠ DI success — Uber/fx resolves dependencies at **runtime**.
  - Start the generated application **normally** with the following script, **do not use anything else**
    ```sh
    go run main.go {your-new-command} &
    PID=$!
    sleep 5
    kill $PID 2>/dev/null
    wait $PID 2>/dev/null
    echo "Dependency injection test completed"
    ```
  - Observe logs for errors such as:
    - `"could not build arguments for function"`
    - `"did you mean to use"`
  - If errors occur:
    1. Read the service logs carefully.
    2. Follow the instructions or hints in the log to fix missing/wrong DI bindings.
  - Ignore errors unrelated to the DI workflow.
